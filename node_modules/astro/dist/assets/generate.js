import fs from "node:fs";
import { basename, join } from "node:path/posix";
import { warn } from "../core/logger/core.js";
import { prependForwardSlash } from "../core/path.js";
import { isHybridOutput } from "../prerender/utils.js";
import { getConfiguredImageService, isESMImportedImage } from "./internal.js";
async function generateImage(buildOpts, options, filepath) {
  if (!isESMImportedImage(options.src)) {
    return void 0;
  }
  let useCache = true;
  const assetsCacheDir = new URL("assets/", buildOpts.settings.config.cacheDir);
  try {
    await fs.promises.mkdir(assetsCacheDir, { recursive: true });
  } catch (err) {
    warn(
      buildOpts.logging,
      "astro:assets",
      `An error was encountered while creating the cache directory. Proceeding without caching. Error: ${err}`
    );
    useCache = false;
  }
  let serverRoot, clientRoot;
  if (buildOpts.settings.config.output === "server" || isHybridOutput(buildOpts.settings.config)) {
    serverRoot = buildOpts.settings.config.build.server;
    clientRoot = buildOpts.settings.config.build.client;
  } else {
    serverRoot = buildOpts.settings.config.outDir;
    clientRoot = buildOpts.settings.config.outDir;
  }
  const finalFileURL = new URL("." + filepath, clientRoot);
  const finalFolderURL = new URL("./", finalFileURL);
  const cachedFileURL = new URL(basename(filepath), assetsCacheDir);
  try {
    await fs.promises.copyFile(cachedFileURL, finalFileURL);
    return {
      cached: true
    };
  } catch (e) {
  }
  const originalImagePath = options.src.src;
  const fileData = await fs.promises.readFile(
    new URL(
      "." + prependForwardSlash(
        join(buildOpts.settings.config.build.assets, basename(originalImagePath))
      ),
      serverRoot
    )
  );
  const imageService = await getConfiguredImageService();
  const resultData = await imageService.transform(
    fileData,
    { ...options, src: originalImagePath },
    buildOpts.settings.config.image.service.config
  );
  await fs.promises.mkdir(finalFolderURL, { recursive: true });
  if (useCache) {
    try {
      await fs.promises.writeFile(cachedFileURL, resultData.data);
      await fs.promises.copyFile(cachedFileURL, finalFileURL);
    } catch (e) {
      warn(
        buildOpts.logging,
        "astro:assets",
        `An error was encountered while creating the cache directory. Proceeding without caching. Error: ${e}`
      );
      await fs.promises.writeFile(finalFileURL, resultData.data);
    }
  } else {
    await fs.promises.writeFile(finalFileURL, resultData.data);
  }
  return {
    cached: false,
    weight: {
      before: Math.trunc(fileData.byteLength / 1024),
      after: Math.trunc(resultData.data.byteLength / 1024)
    }
  };
}
function getStaticImageList() {
  var _a, _b;
  if (!((_a = globalThis == null ? void 0 : globalThis.astroAsset) == null ? void 0 : _a.staticImages)) {
    return [];
  }
  return (_b = globalThis.astroAsset.staticImages) == null ? void 0 : _b.entries();
}
export {
  generateImage,
  getStaticImageList
};
