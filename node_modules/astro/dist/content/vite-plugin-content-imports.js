import * as devalue from "devalue";
import { extname } from "node:path";
import { pathToFileURL } from "url";
import { AstroErrorData } from "../core/errors/errors-data.js";
import { AstroError } from "../core/errors/errors.js";
import { escapeViteEnvReferences, getFileInfo } from "../vite-plugin-utils/index.js";
import { CONTENT_FLAG, DATA_FLAG } from "./consts.js";
import {
  getContentEntryConfigByExtMap,
  getContentEntryExts,
  getContentEntryIdAndSlug,
  getContentPaths,
  getDataEntryExts,
  getDataEntryId,
  getEntryCollectionName,
  getEntryData,
  getEntryType,
  globalContentConfigObserver,
  hasContentFlag,
  parseEntrySlug,
  reloadContentConfigObserver
} from "./utils.js";
function getContentRendererByViteId(viteId, settings) {
  let ext = viteId.split(".").pop();
  if (!ext)
    return void 0;
  for (const contentEntryType of settings.contentEntryTypes) {
    if (Boolean(contentEntryType.getRenderModule) && contentEntryType.extensions.includes("." + ext)) {
      return contentEntryType.getRenderModule;
    }
  }
  return void 0;
}
const CHOKIDAR_MODIFIED_EVENTS = ["add", "unlink", "change"];
const COLLECTION_TYPES_TO_INVALIDATE_ON = ["data", "content", "config"];
function astroContentImportPlugin({
  fs,
  settings
}) {
  const contentPaths = getContentPaths(settings.config, fs);
  const contentEntryExts = getContentEntryExts(settings);
  const dataEntryExts = getDataEntryExts(settings);
  const contentEntryConfigByExt = getContentEntryConfigByExtMap(settings);
  const dataEntryExtToParser = /* @__PURE__ */ new Map();
  for (const entryType of settings.dataEntryTypes) {
    for (const ext of entryType.extensions) {
      dataEntryExtToParser.set(ext, entryType.getEntryInfo);
    }
  }
  const plugins = [
    {
      name: "astro:content-imports",
      async transform(_, viteId) {
        if (hasContentFlag(viteId, DATA_FLAG)) {
          const fileId = viteId.split("?")[0] ?? viteId;
          const { id, data, collection, _internal } = await getDataEntryModule({
            fileId,
            dataEntryExtToParser,
            contentPaths,
            settings,
            fs,
            pluginContext: this
          });
          const code = escapeViteEnvReferences(`
export const id = ${JSON.stringify(id)};
export const collection = ${JSON.stringify(collection)};
export const data = ${devalue.uneval(data)};
export const _internal = {
	type: 'data',
	filePath: ${JSON.stringify(_internal.filePath)},
	rawData: ${JSON.stringify(_internal.rawData)},
};
`);
          return code;
        } else if (hasContentFlag(viteId, CONTENT_FLAG)) {
          const fileId = viteId.split("?")[0];
          const { id, slug, collection, body, data, _internal } = await setContentEntryModuleCache({
            fileId,
            pluginContext: this
          });
          const code = escapeViteEnvReferences(`
						export const id = ${JSON.stringify(id)};
						export const collection = ${JSON.stringify(collection)};
						export const slug = ${JSON.stringify(slug)};
						export const body = ${JSON.stringify(body)};
						export const data = ${devalue.uneval(data)};
						export const _internal = {
							type: 'content',
							filePath: ${JSON.stringify(_internal.filePath)},
							rawData: ${JSON.stringify(_internal.rawData)},
						};`);
          return { code, map: { mappings: "" } };
        }
      },
      configureServer(viteServer) {
        viteServer.watcher.on("all", async (event, entry) => {
          if (CHOKIDAR_MODIFIED_EVENTS.includes(event)) {
            const entryType = getEntryType(
              entry,
              contentPaths,
              contentEntryExts,
              dataEntryExts,
              settings.config.experimental.assets
            );
            if (!COLLECTION_TYPES_TO_INVALIDATE_ON.includes(entryType))
              return;
            if (entryType === "content" || entryType === "data") {
              await reloadContentConfigObserver({ fs, settings, viteServer });
            }
            for (const modUrl of viteServer.moduleGraph.urlToModuleMap.keys()) {
              if (hasContentFlag(modUrl, CONTENT_FLAG) || hasContentFlag(modUrl, DATA_FLAG) || Boolean(getContentRendererByViteId(modUrl, settings))) {
                const mod = await viteServer.moduleGraph.getModuleByUrl(modUrl);
                if (mod) {
                  viteServer.moduleGraph.invalidateModule(mod);
                }
              }
            }
          }
        });
      }
    }
  ];
  if (settings.contentEntryTypes.some((t) => t.getRenderModule)) {
    plugins.push({
      name: "astro:content-render-imports",
      async transform(_, viteId) {
        const contentRenderer = getContentRendererByViteId(viteId, settings);
        if (!contentRenderer)
          return;
        const { fileId } = getFileInfo(viteId, settings.config);
        const entry = await getContentEntryModuleFromCache(fileId);
        if (!entry) {
          throw new AstroError({
            ...AstroErrorData.UnknownContentCollectionError,
            message: `Unable to render ${JSON.stringify(
              fileId
            )}. Did you import this module directly without using a content collection query?`
          });
        }
        return contentRenderer.bind(this)({ entry, viteId });
      }
    });
  }
  const contentEntryModuleByIdCache = /* @__PURE__ */ new Map();
  function isAwaitingQueue(cacheEntry) {
    return typeof cacheEntry === "object" && cacheEntry != null && "awaitingQueue" in cacheEntry;
  }
  function getContentEntryModuleFromCache(id) {
    const cacheEntry = contentEntryModuleByIdCache.get(id);
    if (isAwaitingQueue(cacheEntry)) {
      return new Promise((resolve, reject) => {
        cacheEntry.awaitingQueue.push(resolve);
      });
    } else if (cacheEntry) {
      return Promise.resolve(cacheEntry);
    }
    return Promise.resolve(void 0);
  }
  async function setContentEntryModuleCache({
    fileId,
    pluginContext
  }) {
    contentEntryModuleByIdCache.set(fileId, { awaitingQueue: [] });
    const contentConfig = await getContentConfigFromGlobal();
    const rawContents = await fs.promises.readFile(fileId, "utf-8");
    const fileExt = extname(fileId);
    if (!contentEntryConfigByExt.has(fileExt)) {
      throw new AstroError({
        ...AstroErrorData.UnknownContentCollectionError,
        message: `No parser found for content entry ${JSON.stringify(
          fileId
        )}. Did you apply an integration for this file type?`
      });
    }
    const contentEntryConfig = contentEntryConfigByExt.get(fileExt);
    const {
      rawData,
      body,
      slug: frontmatterSlug,
      data: unvalidatedData
    } = await contentEntryConfig.getEntryInfo({
      fileUrl: pathToFileURL(fileId),
      contents: rawContents
    });
    const entry = pathToFileURL(fileId);
    const { contentDir } = contentPaths;
    const collection = getEntryCollectionName({ entry, contentDir });
    if (collection === void 0)
      throw new AstroError(AstroErrorData.UnknownContentCollectionError);
    const { id, slug: generatedSlug } = getContentEntryIdAndSlug({ entry, contentDir, collection });
    const _internal = { filePath: fileId, rawData };
    const slug = parseEntrySlug({
      id,
      collection,
      generatedSlug,
      frontmatterSlug
    });
    const collectionConfig = contentConfig == null ? void 0 : contentConfig.collections[collection];
    let data = collectionConfig ? await getEntryData(
      { id, collection, _internal, unvalidatedData },
      collectionConfig,
      pluginContext,
      settings.config
    ) : unvalidatedData;
    const contentEntryModule = {
      id,
      slug,
      collection,
      data,
      body,
      _internal
    };
    const cacheEntry = contentEntryModuleByIdCache.get(fileId);
    if (isAwaitingQueue(cacheEntry)) {
      for (const resolve of cacheEntry.awaitingQueue) {
        resolve(contentEntryModule);
      }
    }
    contentEntryModuleByIdCache.set(fileId, contentEntryModule);
    return contentEntryModule;
  }
  return plugins;
}
async function getContentConfigFromGlobal() {
  const observable = globalContentConfigObserver.get();
  if (observable.status === "init") {
    throw new AstroError({
      ...AstroErrorData.UnknownContentCollectionError,
      message: "Content config failed to load."
    });
  }
  if (observable.status === "error") {
    throw observable.error;
  }
  let contentConfig = observable.status === "loaded" ? observable.config : void 0;
  if (observable.status === "loading") {
    contentConfig = await new Promise((resolve) => {
      const unsubscribe = globalContentConfigObserver.subscribe((ctx) => {
        if (ctx.status === "loaded") {
          resolve(ctx.config);
          unsubscribe();
        }
        if (ctx.status === "error") {
          resolve(void 0);
          unsubscribe();
        }
      });
    });
  }
  return contentConfig;
}
async function getDataEntryModule({
  fileId,
  dataEntryExtToParser,
  contentPaths,
  fs,
  pluginContext,
  settings
}) {
  const contentConfig = await getContentConfigFromGlobal();
  let rawContents;
  try {
    rawContents = await fs.promises.readFile(fileId, "utf-8");
  } catch (e) {
    throw new AstroError({
      ...AstroErrorData.UnknownContentCollectionError,
      message: `Unexpected error reading entry ${JSON.stringify(fileId)}.`,
      stack: e instanceof Error ? e.stack : void 0
    });
  }
  const fileExt = extname(fileId);
  const dataEntryParser = dataEntryExtToParser.get(fileExt);
  if (!dataEntryParser) {
    throw new AstroError({
      ...AstroErrorData.UnknownContentCollectionError,
      message: `No parser found for data entry ${JSON.stringify(
        fileId
      )}. Did you apply an integration for this file type?`
    });
  }
  const { data: unvalidatedData, rawData = "" } = await dataEntryParser({
    fileUrl: pathToFileURL(fileId),
    contents: rawContents
  });
  const entry = pathToFileURL(fileId);
  const { contentDir } = contentPaths;
  const collection = getEntryCollectionName({ entry, contentDir });
  if (collection === void 0)
    throw new AstroError(AstroErrorData.UnknownContentCollectionError);
  const id = getDataEntryId({ entry, contentDir, collection });
  const _internal = { filePath: fileId, rawData };
  const collectionConfig = contentConfig == null ? void 0 : contentConfig.collections[collection];
  const data = collectionConfig ? await getEntryData(
    { id, collection, _internal, unvalidatedData },
    collectionConfig,
    pluginContext,
    settings.config
  ) : unvalidatedData;
  return { id, collection, data, _internal };
}
export {
  astroContentImportPlugin
};
