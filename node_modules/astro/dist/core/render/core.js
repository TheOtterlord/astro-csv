import { renderPage as runtimeRenderPage } from "../../runtime/server/index.js";
import { attachToResponse } from "../cookies/index.js";
import { AstroError, AstroErrorData } from "../errors/index.js";
import { getParams } from "../routing/params.js";
import { createResult } from "./result.js";
import { callGetStaticPaths, findPathItemByKey } from "./route-cache.js";
var GetParamsAndPropsError = /* @__PURE__ */ ((GetParamsAndPropsError2) => {
  GetParamsAndPropsError2[GetParamsAndPropsError2["NoMatchingStaticPath"] = 0] = "NoMatchingStaticPath";
  return GetParamsAndPropsError2;
})(GetParamsAndPropsError || {});
async function getParamsAndPropsOrThrow(options) {
  var _a, _b;
  let paramsAndPropsResp = await getParamsAndProps(options);
  if (paramsAndPropsResp === 0 /* NoMatchingStaticPath */) {
    throw new AstroError({
      ...AstroErrorData.NoMatchingStaticPathFound,
      message: AstroErrorData.NoMatchingStaticPathFound.message(options.pathname),
      hint: ((_a = options.route) == null ? void 0 : _a.component) ? AstroErrorData.NoMatchingStaticPathFound.hint([(_b = options.route) == null ? void 0 : _b.component]) : ""
    });
  }
  return paramsAndPropsResp;
}
async function getParamsAndProps(opts) {
  const { logging, mod, route, routeCache, pathname, ssr } = opts;
  let params = {};
  let pageProps;
  if (route && !route.pathname) {
    if (route.params.length) {
      const paramsMatch = route.pattern.exec(decodeURIComponent(pathname));
      if (paramsMatch) {
        params = getParams(route.params)(paramsMatch);
        if (route.type === "endpoint" && mod.getStaticPaths) {
          const lastSegment = route.segments[route.segments.length - 1];
          const paramValues = Object.values(params);
          const lastParam = paramValues[paramValues.length - 1];
          if (lastSegment.length === 1 && lastSegment[0].dynamic && lastParam === void 0) {
            throw new AstroError({
              ...AstroErrorData.PrerenderDynamicEndpointPathCollide,
              message: AstroErrorData.PrerenderDynamicEndpointPathCollide.message(route.route),
              hint: AstroErrorData.PrerenderDynamicEndpointPathCollide.hint(route.component),
              location: {
                file: route.component
              }
            });
          }
        }
      }
    }
    let routeCacheEntry = routeCache.get(route);
    if (!routeCacheEntry) {
      routeCacheEntry = await callGetStaticPaths({ mod, route, isValidate: true, logging, ssr });
      routeCache.set(route, routeCacheEntry);
    }
    const matchedStaticPath = findPathItemByKey(routeCacheEntry.staticPaths, params, route);
    if (!matchedStaticPath && (ssr ? mod.prerender : true)) {
      return 0 /* NoMatchingStaticPath */;
    }
    pageProps = (matchedStaticPath == null ? void 0 : matchedStaticPath.props) ? { ...matchedStaticPath.props } : {};
  } else {
    pageProps = {};
  }
  return [params, pageProps];
}
async function renderPage({ mod, renderContext, env, apiContext }) {
  const Component = mod.default;
  if (!Component)
    throw new Error(`Expected an exported Astro component but received typeof ${typeof Component}`);
  let locals = {};
  if (apiContext) {
    if (env.mode === "development" && !isValueSerializable(apiContext.locals)) {
      throw new AstroError({
        ...AstroErrorData.LocalsNotSerializable,
        message: AstroErrorData.LocalsNotSerializable.message(renderContext.pathname)
      });
    }
    locals = apiContext.locals;
  }
  const result = createResult({
    adapterName: env.adapterName,
    links: renderContext.links,
    styles: renderContext.styles,
    logging: env.logging,
    markdown: env.markdown,
    mode: env.mode,
    origin: renderContext.origin,
    params: renderContext.params,
    props: renderContext.props,
    pathname: renderContext.pathname,
    componentMetadata: renderContext.componentMetadata,
    resolve: env.resolve,
    renderers: env.renderers,
    clientDirectives: env.clientDirectives,
    request: renderContext.request,
    site: env.site,
    scripts: renderContext.scripts,
    ssr: env.ssr,
    status: renderContext.status ?? 200,
    locals
  });
  if (typeof mod.components === "object") {
    Object.assign(renderContext.props, { components: mod.components });
  }
  let response = await runtimeRenderPage(
    result,
    Component,
    renderContext.props,
    null,
    env.streaming,
    renderContext.route
  );
  if (result.cookies) {
    attachToResponse(response, result.cookies);
  }
  return response;
}
function isValueSerializable(value) {
  let type = typeof value;
  let plainObject = true;
  if (type === "object" && isPlainObject(value)) {
    for (const [, nestedValue] of Object.entries(value)) {
      if (!isValueSerializable(nestedValue)) {
        plainObject = false;
        break;
      }
    }
  } else {
    plainObject = false;
  }
  let result = value === null || type === "string" || type === "number" || type === "boolean" || Array.isArray(value) || plainObject;
  return result;
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  let proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  let baseProto = proto;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto === baseProto;
}
export {
  GetParamsAndPropsError,
  getParamsAndProps,
  getParamsAndPropsOrThrow,
  isValueSerializable,
  renderPage
};
